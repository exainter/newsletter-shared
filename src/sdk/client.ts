/**
 * Generated by orval v6.31.0 ðŸº
 * Do not edit manually.
 * Newsletter SaaS API
 * OpenAPI spec version: 1.0.0
 */
export type GetAggregatedInsightsInsightsGetParams = {
  /**
   * Optional period filter (e.g., '2025-10')
   */
  period?: string;
};

export type ListCampaignsCampaignsGetParams = {
  limit?: number;
  cursor?: string | null;
};

export type ByEmailEventsByEmailGetParams = {
  email: string;
  since: string;
  until: string;
  limit?: number;
  cursor?: string | null;
};

export type ByCampaignEventsByCampaignGetParams = {
  campaign_id: string;
  since: string;
  until: string;
  limit?: number;
  cursor?: string | null;
};

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export interface SummaryTotals {
  bounces?: number;
  clicks?: number;
  complaints?: number;
  delivered?: number;
  opens?: number;
}

export interface SummaryRates {
  bounce_rate?: number;
  click_rate?: number;
  complaint_rate?: number;
  open_rate?: number;
}

export interface Summary {
  rates: SummaryRates;
  totals: SummaryTotals;
}

export type InsightsResponseSeries = { [key: string]: unknown };

export type InsightsResponseInterval =
  (typeof InsightsResponseInterval)[keyof typeof InsightsResponseInterval];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InsightsResponseInterval = {
  day: "day",
  hour: "hour",
} as const;

export type InsightsResponseCursor = string | null;

export interface InsightsResponse {
  cursor?: InsightsResponseCursor;
  interval: InsightsResponseInterval;
  series?: InsightsResponseSeries;
  summary: Summary;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export type CampaignMetricsTimestamp = string | null;

export type CampaignMetricsName = string | null;

/**
 * Metrics for a single campaign
 */
export interface CampaignMetrics {
  bounced?: number;
  campaign_id: string;
  clicked?: number;
  name?: CampaignMetricsName;
  opened?: number;
  sent?: number;
  timestamp?: CampaignMetricsTimestamp;
  unsubscribed?: number;
}

/**
 * Summary metrics across all campaigns
 */
export interface AggregatedSummary {
  total_bounce_rate?: number;
  total_click_rate?: number;
  total_open_rate?: number;
  total_sent?: number;
}

export type AggregatedInsightsResponsePeriod = string | null;

/**
 * Response for GET /insights endpoint
 */
export interface AggregatedInsightsResponse {
  campaigns: CampaignMetrics[];
  period?: AggregatedInsightsResponsePeriod;
  summary: AggregatedSummary;
  tenant_id: string;
}

/**
 * Health check endpoint (no authentication required).
 * @summary Health
 */
export type healthHealthGetResponse = {
  data: unknown;
  status: number;
};

export const getHealthHealthGetUrl = () => {
  return `/health`;
};

export const healthHealthGet = async (
  options?: RequestInit,
): Promise<healthHealthGetResponse> => {
  const res = await fetch(getHealthHealthGetUrl(), {
    ...options,
    method: "GET",
  });
  const data = await res.json();

  return { status: res.status, data };
};

/**
 * Kubernetes-style health check endpoint (no authentication required).
Suitable for AWS API Gateway health checks and load balancer integration.

Returns:
    {
        "status": "healthy",
        "environment": "prod",
        "version": "1.0.0",
        "timestamp": "2025-11-03T00:00:00Z"
    }
 * @summary Healthz
 */
export type healthzHealthzGetResponse = {
  data: unknown;
  status: number;
};

export const getHealthzHealthzGetUrl = () => {
  return `/healthz`;
};

export const healthzHealthzGet = async (
  options?: RequestInit,
): Promise<healthzHealthzGetResponse> => {
  const res = await fetch(getHealthzHealthzGetUrl(), {
    ...options,
    method: "GET",
  });
  const data = await res.json();

  return { status: res.status, data };
};

/**
 * Get current authenticated user's information.

Requires: JWT token with tenant_id claim (via Authorization header or API Gateway authorizer)

Returns:
    {
        "email": "user@example.com",
        "tenant_id": "tenant-123",
        "claims": {...}
    }
 * @summary User Me
 */
export type userMeUserMeGetResponse = {
  data: unknown;
  status: number;
};

export const getUserMeUserMeGetUrl = () => {
  return `/user/me`;
};

export const userMeUserMeGet = async (
  options?: RequestInit,
): Promise<userMeUserMeGetResponse> => {
  const res = await fetch(getUserMeUserMeGetUrl(), {
    ...options,
    method: "GET",
  });
  const data = await res.json();

  return { status: res.status, data };
};

/**
 * @summary By Campaign
 */
export type byCampaignEventsByCampaignGetResponse = {
  data: InsightsResponse;
  status: number;
};

export const getByCampaignEventsByCampaignGetUrl = (
  params: ByCampaignEventsByCampaignGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return `/events/by-campaign?${normalizedParams.toString()}`;
};

export const byCampaignEventsByCampaignGet = async (
  params: ByCampaignEventsByCampaignGetParams,
  options?: RequestInit,
): Promise<byCampaignEventsByCampaignGetResponse> => {
  const res = await fetch(getByCampaignEventsByCampaignGetUrl(params), {
    ...options,
    method: "GET",
  });
  const data = await res.json();

  return { status: res.status, data };
};

/**
 * @summary By Email
 */
export type byEmailEventsByEmailGetResponse = {
  data: InsightsResponse;
  status: number;
};

export const getByEmailEventsByEmailGetUrl = (
  params: ByEmailEventsByEmailGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return `/events/by-email?${normalizedParams.toString()}`;
};

export const byEmailEventsByEmailGet = async (
  params: ByEmailEventsByEmailGetParams,
  options?: RequestInit,
): Promise<byEmailEventsByEmailGetResponse> => {
  const res = await fetch(getByEmailEventsByEmailGetUrl(params), {
    ...options,
    method: "GET",
  });
  const data = await res.json();

  return { status: res.status, data };
};

/**
 * List campaigns for the authenticated tenant.
 * @summary List Campaigns
 */
export type listCampaignsCampaignsGetResponse = {
  data: unknown;
  status: number;
};

export const getListCampaignsCampaignsGetUrl = (
  params?: ListCampaignsCampaignsGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return `/campaigns?${normalizedParams.toString()}`;
};

export const listCampaignsCampaignsGet = async (
  params?: ListCampaignsCampaignsGetParams,
  options?: RequestInit,
): Promise<listCampaignsCampaignsGetResponse> => {
  const res = await fetch(getListCampaignsCampaignsGetUrl(params), {
    ...options,
    method: "GET",
  });
  const data = await res.json();

  return { status: res.status, data };
};

/**
 * Get aggregated campaign metrics for the authenticated tenant.

This endpoint scans the campaign_agg table and aggregates metrics by campaign_id.
It returns summary statistics and per-campaign breakdowns.
 * @summary Get Aggregated Insights
 */
export type getAggregatedInsightsInsightsGetResponse = {
  data: AggregatedInsightsResponse;
  status: number;
};

export const getGetAggregatedInsightsInsightsGetUrl = (
  params?: GetAggregatedInsightsInsightsGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return `/insights?${normalizedParams.toString()}`;
};

export const getAggregatedInsightsInsightsGet = async (
  params?: GetAggregatedInsightsInsightsGetParams,
  options?: RequestInit,
): Promise<getAggregatedInsightsInsightsGetResponse> => {
  const res = await fetch(getGetAggregatedInsightsInsightsGetUrl(params), {
    ...options,
    method: "GET",
  });
  const data = await res.json();

  return { status: res.status, data };
};
